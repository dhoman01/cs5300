.globl main
.text

main:   la $gp, GA
	ori $fp, $sp, 0
	# Store the true and false const values
	li $a3 1
	sw $a3, 0($gp)
	sw $zero, 4($gp)
	# Writing expression to output
	# Loading string const
	la $25 S1
	li $v0 4
	ori $a0 $25 0
	syscall
	addi $a0 $0 0xA #ascii code for LF, if you have any trouble try 0xD for CR.
	addi $v0 $0 0xB #syscall 11 prints the lower 8 bits of $a0 as an ascii character.
	syscall
	# Storing the value 1 in a
	li $25 1
	sw $25 8($gp)
	# Storing the value 2 in b
	li $25 2
	sw $25 12($gp)
	# Loading value from 8($gp) with type integer
	lw $25 8($gp)
	# Loading value from 12($gp) with type integer
	lw $24 12($gp)
	# Writing expression to output
	li $v0 1
	ori $a0 $25 0
	syscall
	addi $a0 $0 0xA #ascii code for LF, if you have any trouble try 0xD for CR.
	addi $v0 $0 0xB #syscall 11 prints the lower 8 bits of $a0 as an ascii character.
	syscall
	# Writing expression to output
	li $v0 1
	ori $a0 $24 0
	syscall
	addi $a0 $0 0xA #ascii code for LF, if you have any trouble try 0xD for CR.
	addi $v0 $0 0xB #syscall 11 prints the lower 8 bits of $a0 as an ascii character.
	syscall
	# Loading value from 8($gp) with type integer
	lw $24 8($gp)
	# Loading value from 12($gp) with type integer
	lw $25 12($gp)
	# Expression: 642122192 + 642122192
	add $23 $24 $25
	# Storing the expr at $23 in a
	sw $23 8($gp)
	# Loading value from 8($gp) with type integer
	lw $23 8($gp)
	# Loading value from 12($gp) with type integer
	lw $25 12($gp)
	# Expression: 642122192 + 642122192
	add $24 $23 $25
	# Storing the expr at $24 in b
	sw $24 12($gp)
	# Loading value from 8($gp) with type integer
	lw $24 8($gp)
	# Loading value from 12($gp) with type integer
	lw $25 12($gp)
	# Writing expression to output
	li $v0 1
	ori $a0 $24 0
	syscall
	addi $a0 $0 0xA #ascii code for LF, if you have any trouble try 0xD for CR.
	addi $v0 $0 0xB #syscall 11 prints the lower 8 bits of $a0 as an ascii character.
	syscall
	# Writing expression to output
	li $v0 1
	ori $a0 $25 0
	syscall
	addi $a0 $0 0xA #ascii code for LF, if you have any trouble try 0xD for CR.
	addi $v0 $0 0xB #syscall 11 prints the lower 8 bits of $a0 as an ascii character.
	syscall
	# Loading value from 8($gp) with type integer
	lw $25 8($gp)
	# Loading value from 12($gp) with type integer
	lw $24 12($gp)
	# 642122192 * 642122192
	mult $25 $24
	mflo $23
	# Storing the expr at $23 in a
	sw $23 8($gp)
	# Loading value from 8($gp) with type integer
	lw $23 8($gp)
	# Loading value from 12($gp) with type integer
	lw $24 12($gp)
	# 642122192 * 642122192
	mult $23 $24
	mflo $25
	# Storing the expr at $25 in b
	sw $25 12($gp)
	# Loading value from 8($gp) with type integer
	lw $25 8($gp)
	# Loading value from 12($gp) with type integer
	lw $24 12($gp)
	# Writing expression to output
	li $v0 1
	ori $a0 $25 0
	syscall
	addi $a0 $0 0xA #ascii code for LF, if you have any trouble try 0xD for CR.
	addi $v0 $0 0xB #syscall 11 prints the lower 8 bits of $a0 as an ascii character.
	syscall
	# Writing expression to output
	li $v0 1
	ori $a0 $24 0
	syscall
	addi $a0 $0 0xA #ascii code for LF, if you have any trouble try 0xD for CR.
	addi $v0 $0 0xB #syscall 11 prints the lower 8 bits of $a0 as an ascii character.
	syscall
	# Loading value from 12($gp) with type integer
	lw $24 12($gp)
	# Loading value from 8($gp) with type integer
	lw $25 8($gp)
	# 642122192 - 642122192
	sub $23 $24 $25
	# Storing the expr at $23 in a
	sw $23 8($gp)
	# Loading value from 8($gp) with type integer
	lw $23 8($gp)
	# Loading value from 12($gp) with type integer
	lw $25 12($gp)
	# 642122192 - 642122192
	sub $24 $23 $25
	# Storing the expr at $24 in b
	sw $24 12($gp)
	# Loading value from 8($gp) with type integer
	lw $24 8($gp)
	# Loading value from 12($gp) with type integer
	lw $25 12($gp)
	# Writing expression to output
	li $v0 1
	ori $a0 $24 0
	syscall
	addi $a0 $0 0xA #ascii code for LF, if you have any trouble try 0xD for CR.
	addi $v0 $0 0xB #syscall 11 prints the lower 8 bits of $a0 as an ascii character.
	syscall
	# Writing expression to output
	li $v0 1
	ori $a0 $25 0
	syscall
	addi $a0 $0 0xA #ascii code for LF, if you have any trouble try 0xD for CR.
	addi $v0 $0 0xB #syscall 11 prints the lower 8 bits of $a0 as an ascii character.
	syscall
	# Writing expression to output
	# Loading string const
	la $25 S2
	li $v0 4
	ori $a0 $25 0
	syscall
	addi $a0 $0 0xA #ascii code for LF, if you have any trouble try 0xD for CR.
	addi $v0 $0 0xB #syscall 11 prints the lower 8 bits of $a0 as an ascii character.
	syscall
	.data
S1: .asciiz "Beginning Program"
S2: .asciiz "Ending Program"
.align 2
GA:
